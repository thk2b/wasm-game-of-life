const style = {
    cell: {
        size: 1,
        alive: 'green',
        dead: 'blue'
    }
};

const elements = {
    controls: {
        step_button: document.getElementById("controls_step"),
        run_button: document.getElementById("controls_run"),
    },
    canvas: document.getElementById("canvas"),
    metrics: {
        render: document.getElementById("metrics_render"),
        update: document.getElementById("metrics_update"),
        total: document.getElementById("metrics_total"),
    }
};

const state = {
    running: false,
    // fps: 1
};

function render(ctx, board) {
    const pixels = board.h * board.w;
    const img = ctx.getImageData(0, 0, pixels / board.w, pixels / board.h);
    const data = img.data;
    const data_size = pixels * 4;
    let cell = 0;
    for (let i = 0; i < data_size; i += 4) {
        data[i + 0] = 0;
        data[i + 1] = board.data[cell] ? 255 : 0;
        data[i + 2] = board.data[cell] ? 0 : 255;
        data[i + 3] = 255;
        cell++;
    }
    ctx.putImageData(img, 0, 0);
}

function render1(ctx, board) {
    const pixels = board.h * board.w * style.cell.size;
    const img = ctx.getImageData(0, 0, board.w * style.cell.size, board.h * style.cell.size);
    const data = img.data;
    const data_size = pixels * 4;
    const n_cells = board.w * board.h;

    const blue = [0, 0, 255, 255];
    for (let cell = 0; cell < n_cells; cell++) {
        let cur = cell * style.cell.size * 4;
        const w = style.cell.size;
        for (let y = 0; y < w; y++) {
            for (let x = 0; x < w; x++, cur += 3) {
                data[cur + x + 0] = blue[0]
                data[cur + x + 1] = blue[1];
                data[cur + x + 2] = blue[2];
                data[cur + x + 3] = blue[3];
            }
            cur = y * board.w * style.cell.size * 4 + cell * style.cell.size * 4;
        }
    }
    console.log(data);
    ctx.putImageData(img, 0, 0);
}


function render1(ctx, board) {
    for (let y = 0; y < board.h; y++) {
        for (let x = 0; x < board.w; x++) {
            if (board.data[y * board.w + x]) {
                ctx.fillStyle = style.cell.alive;
            } else {
                ctx.fillStyle = style.cell.dead;
            }
            ctx.fillRect(x * style.cell.size, y * style.cell.size, style.cell.size, style.cell.size);
        }
    }
}

function time(el, cb) {
    const begin = performance.now();
    cb();
    const ms = performance.now() - begin;
    el.innerHTML = ms.toString();
}

function step(ctx, board, timestamp) {
    time(elements.metrics.update, () => _goli_step(board.data, board.x, board.y));
    time(elements.metrics.render, () => render(ctx, board));
}

function loop(state, ctx, board) {
    if (state.running) {
        window.requestAnimationFrame((timestamp) => {
            time(elements.metrics.total, () => step(ctx, board, timestamp));
            loop(state, ctx, board);
        })
    }
}

function set_canvas_size(cvs, board) {
    cvs.width = board.w * style.cell.size;
    cvs.height = board.h * style.cell.size;
}

function main() {
    _goli_init();
    const board = {
        data: new Uint8Array(Module.buffer, _goli_get_board()),
        w: _goli_get_width(),
        h: _goli_get_height(),
    };
    set_canvas_size(elements.canvas, board);
    const ctx = elements.canvas.getContext("2d");

    render(ctx, board);
    elements.controls.step_button.addEventListener("click", () => {
        board.data = new Uint8Array(Module.buffer, _goli_get_board())
        step(ctx, board, performance.now());
    });

    elements.controls.run_button.addEventListener("click", () => {
        state.running = !state.running;
        if (state.running) {
            loop(state, ctx, board);
        }
    });
}

Module.postRun.push(main);